{"version":3,"file":"neep.router.esm.min.js","sources":["../src/install/context.ts","../src/install/index.ts","../src/View.ts","../src/Link.ts","../src/util.ts","../node_modules/path-to-regexp/dist.es2015/index.js","../src/route.ts","../src/query.ts","../src/history/WebHash.ts","../src/history/Memory.ts","../src/history/WebPath.ts","../src/Router.ts"],"sourcesContent":["import { Context } from '@neep/core';\n\nexport default function contextConstructor(context: Context) {\n\tconst router = context.delivered.__NeepRouter__;\n\tconst depth = context.delivered.__RouteDepth__ || 0;\n\tReflect.defineProperty(context, 'route', {\n\t\tvalue: router,\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t});\n\tReflect.defineProperty(context, 'match', {\n\t\tget: () => router?._get(depth),\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t});\n}","import contextConstructor from './context';\n\nexport let Neep: typeof import ('@neep/core');\nexport default function install(neep: typeof import ('@neep/core')) {\n\tNeep = neep;\n\tNeep.addContextConstructor(contextConstructor);\n}","import { Context, Auxiliary, mName, mSimple } from '@neep/core';\nimport Router from './Router';\nexport default function RouterView(\n\tprops: {name?: string; depth?: number; router?: Router},\n\t{ delivered }: Context,\n\t{ createElement, Deliver, label }: Auxiliary,\n) {\n\tconst isNew = props.router instanceof Router;\n\tconst router = isNew ? props.router : delivered.__NeepRouter__;\n\tif (!(router instanceof Router)) { return; }\n\tlet depth = props.depth;\n\tif (typeof depth === 'number' && Number.isInteger(depth)) {\n\t\tif (depth < 0) { depth = router.size - depth; }\n\t} else {\n\t\tdepth = isNew ? 0 : (delivered.__RouteDepth__ || 0) + 1;\n\t}\n\tif (depth < 0) { return null; }\n\tconst match = router._get(depth);\n\tif (!match) { return; }\n\tconst { route: { components } } = match;\n\tif (!components) { return null; }\n\tconst name = props.name || 'default';\n\tconst component = name in components ? components[name] : undefined;\n\tif (!component) { return null; }\n\tlabel(`[path=${match.path}]`, '#987654');\n\treturn createElement(Deliver, {\n\t\t__RouteDepth__: depth,\n\t\t__NeepRouter__: router,\n\t}, createElement(component, props));\n}\nmSimple(RouterView)\nmName('RouterView', RouterView);","import { Context, Auxiliary, mName, mSimple } from '@neep/core';\nimport { Location } from './type';\nexport default function RouterLink(\n\tprops: { to?: Location | string; replace?: boolean} & Location,\n\tcontext: Context,\n\tauxiliary: Auxiliary,\n) {\n\tconst { route, childNodes } = context;\n\tconst { createElement } = auxiliary;\n\t// return null;screenLeft\n\tif (!route) { return createElement('template', {}, ...childNodes); }\n\tlet {to, append, replace, path, search, hash, query, alias, params} = props;\n\tif (!to) {\n\t\tto = { path, search, hash, query, alias, params };\n\t} else if (typeof to === 'string') {\n\t\tto = { path: to };\n\t}\n\tif (append) {\n\t\tto.append = true;\n\t}\n\tfunction onclick() {\n\t\tif (!route || !to) { return; }\n\t\tif (replace) {\n\t\t\troute.replace(to);\n\t\t} else {\n\t\t\troute.push(to);\n\t\t}\n\t}\n\treturn route\n\t\t.history?.link({...props, to}, context, auxiliary, onclick)\n\t\t|| createElement('span', {onclick}, ...childNodes);\n\n}\nmSimple(RouterLink)\nmName('RouterView', RouterLink);","export function cleanPath(path: string) {\n\tpath = `/${path}`.replace(/\\/+(\\/|$)/g, '$1');\n\twhile(/[^/]+\\/\\.{2,}(\\/|$)/.test(path)) {\n\t\tpath = path.replace(/\\/[^/]+\\/\\.(\\.+(?:\\/|$))/g, '/$1');\n\t}\n\tpath = path.replace(/\\/\\.+(\\/|$)/g, '$1');\n\treturn path || '/';\n}","/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    var tokens = [];\n    var i = 0;\n    while (i < str.length) {\n        var char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            var name = \"\";\n            var j = i + 1;\n            while (j < str.length) {\n                var code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(\"Missing parameter name at \" + i);\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            var count = 1;\n            var pattern = \"\";\n            var j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \" + j);\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(\"Capturing groups are not allowed at \" + j);\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(\"Unbalanced pattern at \" + i);\n            if (!pattern)\n                throw new TypeError(\"Missing pattern at \" + i);\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var tokens = lexer(str);\n    var _a = options.prefixes, prefixes = _a === void 0 ? \"./\" : _a;\n    var defaultPattern = \"[^\" + escapeString(options.delimiter || \"/#?\") + \"]+?\";\n    var result = [];\n    var key = 0;\n    var i = 0;\n    var path = \"\";\n    var tryConsume = function (type) {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    var mustConsume = function (type) {\n        var value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        var _a = tokens[i], nextType = _a.type, index = _a.index;\n        throw new TypeError(\"Unexpected \" + nextType + \" at \" + index + \", expected \" + type);\n    };\n    var consumeText = function () {\n        var result = \"\";\n        var value;\n        // tslint:disable-next-line\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        var char = tryConsume(\"CHAR\");\n        var name = tryConsume(\"NAME\");\n        var pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            var prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix: prefix,\n                suffix: \"\",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        var value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        var open = tryConsume(\"OPEN\");\n        if (open) {\n            var prefix = consumeText();\n            var name_1 = tryConsume(\"NAME\") || \"\";\n            var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n            var suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name_1 || (pattern_1 ? key++ : \"\"),\n                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n                prefix: prefix,\n                suffix: suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\" + token.pattern + \")$\", reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            var optional = token.modifier === \"?\" || token.modifier === \"*\";\n            var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not repeat, but got an array\");\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not be empty\");\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            var typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to be \" + typeOfMessage);\n        }\n        return path;\n    };\n}\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            // tslint:disable-next-line\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    // Use a negative lookahead to match only capturing groups.\n    var groups = path.source.match(/\\((?!\\?)/g);\n    if (groups) {\n        for (var i = 0; i < groups.length; i++) {\n            keys.push({\n                name: i,\n                prefix: \"\",\n                suffix: \"\",\n                modifier: \"\",\n                pattern: \"\"\n            });\n        }\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\" + parts.join(\"|\") + \")\", flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;\n    var endsWith = \"[\" + escapeString(options.endsWith || \"\") + \"]|$\";\n    var delimiter = \"[\" + escapeString(options.delimiter || \"/#?\") + \"]\";\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var prefix = escapeString(encode(token.prefix));\n            var suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        var mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += \"(?:\" + prefix + \"((?:\" + token.pattern + \")(?:\" + suffix + prefix + \"(?:\" + token.pattern + \"))*)\" + suffix + \")\" + mod;\n                    }\n                    else {\n                        route += \"(?:\" + prefix + \"(\" + token.pattern + \")\" + suffix + \")\" + token.modifier;\n                    }\n                }\n                else {\n                    route += \"(\" + token.pattern + \")\" + token.modifier;\n                }\n            }\n            else {\n                route += \"(?:\" + prefix + suffix + \")\" + token.modifier;\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += delimiter + \"?\";\n        route += !options.endsWith ? \"$\" : \"(?=\" + endsWith + \")\";\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1\n            : // tslint:disable-next-line\n                endToken === undefined;\n        if (!strict) {\n            route += \"(?:\" + delimiter + \"(?=\" + endsWith + \"))?\";\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\" + delimiter + \"|\" + endsWith + \")\";\n        }\n    }\n    return new RegExp(route, flags(options));\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\n//# sourceMappingURL=index.js.map","\nimport { match, compile } from 'path-to-regexp';\nimport { RouteConfig, Route, Match } from './type';\nimport { cleanPath } from './util';\n\n\nexport function addRoute(\n\tcfg: RouteConfig,\n\tnamed: Record<string, Route>,\n\tparent?: Route,\n) {\n\tlet { path, children, alias, meta, component, components, ...p } = cfg;\n\tlet end = !(Array.isArray(children) && children.length);\n\tif (!path || path === '*') {\n\t\tpath = ''\n\t\tend = false;\n\t}\n\tif (path[0] !== '/') {\n\t\tpath = `${parent?.path || ''}/${path}`;\n\t}\n\tpath = cleanPath(path);\n\tif (component) {\n\t\tif (!components) {\n\t\t\tcomponents = {};\n\t\t}\n\t\tcomponents.default = component;\n\t}\n\tconst item: Route = {\n\t\t...p,\n\t\tpath,\n\t\talias,\n\t\tcomponent,\n\t\tcomponents,\n\t\tmeta: meta || {},\n\t\ttoPath: compile(path || '', { encode: encodeURIComponent }),\n\t\tmatch: match(path || '', {end, decode: decodeURIComponent}),\n\t}\n\tif (alias) { named[alias] = item; }\n\tif (Array.isArray(children)) {\n\t\titem.children = children.map(c => addRoute(c, named, item));\n\t}\n\treturn item;\n}\n\nexport function *matchRoutes(path: string, routes: Route[] = []): Iterable<Match>{\n\tfor (const route of routes) {\n\t\tconst result = route.match(path);\n\t\tif (!result) { continue; }\n\t\tif (route.components || route.redirect) {\n\t\t\tyield { ...result, route };\n\t\t}\n\t\tif (!route.redirect) {\n\t\t\tyield* matchRoutes(path, route.children);\n\t\t}\n\t\treturn;\n\t}\n}","\nfunction getValue(v: any): string | undefined | null {\n\tif (v === undefined) { return undefined; }\n\tif (v === null) { return null; }\n\tif (v === false) { return undefined; }\n\tif (typeof v === 'number' && !Number.isFinite(v)) { return; }\n\tif (typeof v === 'function') { return; }\n\treturn encodeURIComponent(String(v));\n}\nexport function stringify(s: any): string {\n\tconst list: string[] = [];\n\tfor (const key of Object.keys(s)) {\n\t\tconst value = s[key];\n\t\tconst k = encodeURIComponent(key);\n\t\tif (!Array.isArray(value)) {\n\t\t\tconst v = getValue(value);\n\t\t\tif (v === undefined) { continue; }\n\t\t\tlist.push(v === null ? k : `${k}=${v}`);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (const val of value) {\n\t\t\tconst v = getValue(val);\n\t\t\tif (v === undefined) { continue; }\n\t\t\tlist.push(v === null ? k : `${k}=${v}`);\n\t\t}\n\t}\n\treturn list.join('&');\n}\n\nexport function parse(s: string): object {\n\tconst query = Object.create(null);\n\tfunction set(k: string, v: null | string = null) {\n\t\tif (!(k in query)) {\n\t\t\tquery[k] = v;\n\t\t\treturn;\n\t\t}\n\t\tconst it = query[k];\n\t\tif (Array.isArray(it)) {\n\t\t\tit.push(v);\n\t\t} else {\n\t\t\tquery[k] = [it, v];\n\t\t}\n\n\t}\n\tfor (const it of s.split('&')) {\n\t\tconst index = it.indexOf('=');\n\t\tif (index < 0) {\n\t\t\tset(decodeURIComponent(it));\n\t\t\tcontinue;\n\t\t}\n\t\tconst k = decodeURIComponent(it.substr(0, index));\n\t\tconst v = decodeURIComponent(it.substr(index + 1));\n\t\tset(k, v);\n\t}\n\treturn query;\n}","import { IHistory, Location } from '../type';\nimport Router from '../Router';\nimport { Context, Auxiliary } from '@neep/core';\n\nfunction parse(p: string): [string, string, string] {\n\tconst result = /^([^?#]*)((?:\\?[^#]*)?)((?:#.*)?)$/.exec(p);\n\tif (!result) { return ['/', '', '']; }\n\treturn [result[1] || '/', result[2], result[3]];\n}\n\nexport default class WebPathHistory implements IHistory {\n\trouter: Router;\n\tconstructor(router: Router) {\n\t\tthis.router = router;\n\t\tconst f = () => {\n\t\t\tconst [path, search, hash] = parse(location.hash.substr(1));\n\t\t\tthis.router._update(path, search, hash);\n\t\t}\n\t\twindow.addEventListener('hashchange', f);\n\t\tthis.destroy = () => {\n\t\t\tthis.destroy = () => {};\n\t\t\twindow.removeEventListener('hashchange', f);\n\t\t}\n\t}\n\tstart() {\n\t\tconst [path, search, hash] = parse(location.hash.substr(1));\n\t\tthis.router._update(path, search, hash);\n\t}\n\tdestroy() {}\n\tpush(path: string, search: string, hash: string) {\n\t\tlocation.hash = `#${path}${search}${hash}`;\n\t}\n\treplace(path: string, search: string, hash: string) {\n\t\tlocation.replace(`#${path}${search}${hash}`);\n\t}\n\tgo(index: number) {\n\t\tconst oldHash = location.hash;\n\t\thistory.go(index);\n\t\tconst hash = location.hash;\n\t\tif (hash === oldHash) { return; }\n\t\treturn [...parse(hash.substr(1)), undefined] as [string, string, string, any];\n\t}\n\tback() {\n\t\treturn this.go(-1);\n\t}\n\tforward() {\n\t\treturn this.go(1);\n\t}\n\tlink(\n\t\t{to}: { to: Location },\n\t\t{ childNodes }: Context,\n\t\t{createElement}: Auxiliary,\n\t\tonClick: ()=> void,\n\t) {\n\t\treturn createElement('a', {\n\t\t\thref: `#${this.router.getUrl(to)}`,\n\t\t\tonClick: (e: MouseEvent) => {\n\t\t\t\te.preventDefault(); onClick();\n\t\t\t}\n\t\t}, ...childNodes);\n\t}\n}","import { IHistory } from '../type';\nimport Router from '../Router';\nimport { Auxiliary, Context } from '@neep/core';\n\nexport default class StoreHistory implements IHistory {\n\trouter: Router;\n\tconstructor(router: Router) {\n\t\tthis.router = router;\n\t}\n\tindex = 0;\n\thistory: [string, string, string, any][] = [];\n\tpush(\n\t\tpath: string,\n\t\tsearch: string,\n\t\thash: string,\n\t\tstate: any,\n\t) {\n\t\tthis.history.length = this.index + 1;\n\t\tthis.index++;\n\t\tthis.history.push([path, search, hash, state]);\n\t}\n\treplace(\n\t\tpath: string,\n\t\tsearch: string,\n\t\thash: string,\n\t\tstate: any,\n\t) {\n\t\tthis.history[this.index] = [path, search, hash, state];\n\t}\n\tgo(index: number) {\n\t\tlet newIndex = this.index + index;\n\t\tif (newIndex >= this.history.length) { return; }\n\t\tif (newIndex < 0) { return; }\n\t\tif (newIndex === this.index) { return; }\n\t\tthis.index = newIndex;\n\t\treturn this.history[newIndex];\n\t}\n\tback() {\n\t\treturn this.go(-1);\n\t}\n\tforward() {\n\t\treturn this.go(1);\n\t}\n\tlink(\n\t\tprops: any,\n\t\t{ childNodes }: Context,\n\t\t{ createElement }: Auxiliary,\n\t\tonClick: ()=> void,\n\t) {\n\t\treturn createElement('span', { onClick }, ...childNodes);\n\t}\n}","import { IHistory, Location } from '../type';\nimport Router from '../Router';\nimport { cleanPath } from '../util';\nimport { Context, Auxiliary } from '@neep/core';\n\nexport default class WebPathHistory implements IHistory {\n\treadonly router: Router;\n\treadonly base: string;\n\tconstructor(router: Router, opt?: {\n\t\tbase?: string;\n\t}) {\n\t\tthis.router = router;\n\t\tlet base = cleanPath(opt?.base || '')\n\t\tthis.base = base === '/' ? '' : base;\n\t\tconst f = () => {\n\t\t\tthis.router._update(\n\t\t\t\tthis.getPath(),\n\t\t\t\tlocation.search,\n\t\t\t\tlocation.hash,\n\t\t\t\thistory.state,\n\t\t\t);\n\t\t}\n\t\twindow.addEventListener('popstate', f);\n\t\tthis.destroy = () => {\n\t\t\tthis.destroy = () => {};\n\t\t\twindow.removeEventListener('popstate', f);\n\t\t}\n\t}\n\tstart() {\n\t\tthis.router._update(\n\t\t\tthis.getPath(),\n\t\t\tlocation.search,\n\t\t\tlocation.hash,\n\t\t\thistory.state,\n\t\t);\n\t}\n\tdestroy() {}\n\tpush(\n\t\tpath: string,\n\t\tsearch: string,\n\t\thash: string,\n\t\tstate: any,\n\t) {\n\t\thistory.pushState(state, '', `${this.base}${path}${search}${hash}`);\n\t}\n\treplace(\n\t\tpath: string,\n\t\tsearch: string,\n\t\thash: string,\n\t\tstate: any,\n\t) {\n\t\thistory.replaceState(state, '', `${this.base}${path}${search}${hash}`);\n\t}\n\tprivate getPath() {\n\t\tconst path = location.pathname;\n\t\tconst { base } = this;\n\t\tif (!base) { return path; }\n\t\tif (path.indexOf(`${base}/`) !== 0) { return path; }\n\t\treturn path.substr(base.length);\n\t}\n\tgo(index: number) {\n\t\tconst old = {\n\t\t\tpath: this.getPath(),\n\t\t\tsearch: location.search,\n\t\t\thash: location.hash,\n\t\t\tstate: history.state,\n\t\t}\n\t\thistory.go(index);\n\t\tconst path = this.getPath();\n\t\tconst search = location.search;\n\t\tconst hash = location.hash;\n\t\tconst state = history.state;\n\t\tif (\n\t\t\tpath !== old.path\n\t\t\t|| search !== old.search\n\t\t\t|| hash !== old.hash\n\t\t\t|| state !== old.state\n\t\t) {\n\t\t\treturn [path, search, hash, state] as [string, string, string, any];\n\t\t}\n\t}\n\tback() {\n\t\treturn this.go(-1);\n\t}\n\tforward() {\n\t\treturn this.go(1);\n\t}\n\tlink(\n\t\t{to}: { to: Location },\n\t\t{ childNodes }: Context,\n\t\t{createElement}: Auxiliary,\n\t\tonClick: ()=> void,\n\t) {\n\t\treturn createElement('a', {\n\t\t\thref: `${this.base}${this.router.getUrl(to)}`,\n\t\t\tonClick: (e: MouseEvent) => {\n\t\t\t\te.preventDefault(); onClick();\n\t\t\t}\n\t\t}, ...childNodes);\n\t}\n}","import install, { Neep } from './install';\nimport { Value } from 'monitorable';\nimport RouterView from './View';\nimport RouterLink from './Link';\nimport { Route, Location, IHistory, Match, RouteConfig } from './type';\nimport { cleanPath } from './util';\nimport { addRoute, matchRoutes } from './route';\nimport { stringify, parse } from './query';\nimport * as history from './history';\nimport { Component, mSimple, mName } from '@neep/core';\n\nfunction get(\n\tlocation: Location | string,\n\troutes: Record<string, Route>,\n\tbasePath: string,\n\tstringifyQuery = stringify,\n): {\n\tpath: string;\n\tsearch: string;\n\thash: string;\n} {\n\tif (typeof location === 'string') { location = { path: location }; }\n\n\tconst route = location.alias && routes[location.alias];\n\tconst result = location.path && /^([^?#]*)((?:\\?[^#]*)?)((?:#.*)?)$/\n\t\t.exec(location.path);\n\tlet path = result?.[1] || '';\n\tif (!path) {\n\t\tpath = route ? route.toPath(location.params || {}) : basePath;\n\t} else if (route) {\n\t\tlet routePath = route.toPath(location.params || {});\n\t\tif (!location.append) {\n\t\t\troutePath = routePath.replace(/\\/[^/]*\\/?$/, '');\n\t\t}\n\t\tpath = `${route.toPath(location.params || {})}/${path}`;\n\t} else if (location.append) {\n\t\tpath = `${basePath}/${path}`;\n\t} if (path[0] !== '/') {\n\t\tpath = `${basePath.replace(/\\/[^/]*\\/?$/, '')}/${path}`;\n\t}\n\tpath = cleanPath(path);\n\tconst search = location.query && `?${ stringifyQuery(location.query) }`\n\t\t|| location.search || result?.[2] || '';\n\tconst hash = location.hash || result?.[3] || '';\n\treturn { path, search, hash };\n}\n\nfunction update(\n\tobj: any,\n\tprops: any = {},\n) {\n\tconst newKeys = new Set(Reflect.ownKeys(props));\n\tfor (const k of Reflect.ownKeys(obj)) {\n\t\tif (!newKeys.has(k)) {\n\t\t\tdelete obj[k];\n\t\t}\n\t}\n\tfor (const k of newKeys) {\n\t\tobj[k] = props[k];\n\t}\n\treturn obj;\n}\nconst redirects: string[] = [];\nclass Router {\n\tstatic get history() { return history; }\n\tstatic get install() { return install; }\n\tstatic get View() { return RouterView; }\n\tstatic get Link() { return RouterLink; }\n\tstringify?(query: Record<any, any>): string;\n\tparse?(search: string): Record<any, any>;\n\tprivate _namedRoutes: Record<string, Route> = Object.create(null);\n\tprivate _routes: Route[] = [];\n\thistory?: IHistory;\n\tprivate readonly _size = Neep.value(0);\n\tprivate readonly _nodes: Value<Match | undefined>[] = [];\n\tprivate readonly _matches = Neep.value<Match[]>([]);\n\tprivate readonly _hash = Neep.value('');\n\tprivate readonly _search = Neep.value('');\n\tprivate readonly _alias = Neep.value('');\n\tprivate readonly _path = Neep.value('/');\n\tprivate readonly _state = Neep.value(undefined as any);\n\tget size() { return this._size(); }\n\tget matches() { return this._matches(); }\n\tget alias() { return this._alias(); }\n\tget path(): string { return this._path(); }\n\tget search() { return this._search(); }\n\tget hash() { return this._hash(); }\n\tget state() { return this._state(); }\n\treadonly params: Record<string, string> = Neep.encase(Object.create(null));\n\treadonly query: Record<string, any> = Neep.encase(Object.create(null));\n\treadonly meta: Record<string, any> = Neep.encase(Object.create(null));\n\tconstructor({History, historyOption}: {\n\t\tHistory?: {new(router: Router, opt?: any): IHistory }\n\t\thistoryOption?: any;\n\t}) {\n\t\tif (History) {\n\t\t\tconst history = new History(this, historyOption);\n\t\t\tthis.history = history;\n\t\t\thistory.start?.();\n\t\t}\n\t}\n\tsetRoutes(routes: RouteConfig[]) {\n\t\tconst named = Object.create(null);\n\t\tthis._routes = routes.map(c => addRoute(c, named));\n\t\tthis._namedRoutes = named;\n\t\tthis._update(\n\t\t\tthis._path(),\n\t\t\tthis._search(),\n\t\t\tthis._hash(),\n\t\t\tthis._state(),\n\t\t\ttrue,\n\t\t);\n\t}\n\t_get(index: number): Match | undefined {\n\t\tconst item =  this._nodes[index]?.();\n\t\tif (!item) {\n\t\t\tthis._size();\n\t\t\treturn undefined;\n\t\t}\n\t\treturn item;\n\t}\n\t_update(path: string, search: string, hash: string, state?: any, force = false) {\n\t\tif (this._path() !== path || force) {\n\t\t\tconst matches = [...matchRoutes(path, this._routes)];\n\t\t\tconst last = matches[matches.length - 1] as Match | undefined;\n\t\t\tif (last && !last.route.components) {\n\t\t\t\tredirects.push(path);\n\t\t\t\tif (redirects.length >= 10) {\n\t\t\t\t\tthrow new Neep.Error(\n\t\t\t\t\t\t`Too many consecutive redirect jumps: \\n${\n\t\t\t\t\t\t\tredirects.join('\\n')\n\t\t\t\t\t\t}`,\n\t\t\t\t\t\t'router',\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tconst {redirect, append} = last.route;\n\t\t\t\ttry {\n\t\t\t\t\tthis.replace(\n\t\t\t\t\t\t`${path}${append ? '/' : '/../'}${redirect}`,\n\t\t\t\t\t\tstate);\n\t\t\t\t\treturn ;\n\t\t\t\t} finally {\n\t\t\t\t\tredirects.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst nodes = this._nodes;\n\t\t\tconst nodesLength = nodes.length;\n\t\t\tconst matchesLength = matches.length;\n\t\t\tconst min = Math.min(matchesLength, nodesLength);\n\t\t\tfor (let i = 0; i < min; i++) { nodes[i](matches[i]); }\n\t\t\tfor (let i = min; i < nodesLength; i++) {\n\t\t\t\tnodes[i](undefined);\n\t\t\t}\n\t\t\tfor (let i = min; i < matchesLength; i++) {\n\t\t\t\tnodes[i] = Neep.value(matches[i]);\n\t\t\t}\n\t\t\tnodes.length = matchesLength;\n\t\t\tthis._size(matchesLength);\n\t\t\tthis._matches(matches);\n\t\t\tthis._path(path);\n\t\t\tthis._alias(last?.route?.alias || '');\n\t\t\tupdate(this.params, last?.params || {});\n\t\t\tupdate(this.meta, last?.route?.meta || {});\n\t\t}\n\t\tif (this._search() !== search) {\n\t\t\tthis._search(search);\n\t\t\tupdate(this.query, (this.parse || parse)(search.substr(1)));\n\t\t}\n\t\tthis._hash(hash);\n\t\tthis._state(state);\n\t}\n\tpush(location: Location | string, state?: any) {\n\t\tconst { path, search, hash } = get(\n\t\t\tlocation,\n\t\t\tthis._namedRoutes,\n\t\t\tthis._path(),\n\t\t\tthis.stringify,\n\t\t)\n\t\tthis.history?.push(path, search, hash, state);\n\t\tthis._update(path, search, hash, state);\n\t}\n\treplace(location: Location | string, state?: any) {\n\t\tconst {path, search, hash} = get(\n\t\t\tlocation,\n\t\t\tthis._namedRoutes,\n\t\t\tthis._path(),\n\t\t\tthis.stringify,\n\t\t)\n\t\tthis.history?.replace(path, search, hash, state);\n\t\tthis._update(path, search, hash, state);\n\t}\n\tgetUrl(location: Location | string) {\n\t\tconst {path, search, hash} = get(\n\t\t\tlocation,\n\t\t\tthis._namedRoutes,\n\t\t\tthis._path(),\n\t\t\tthis.stringify,\n\t\t)\n\t\treturn `${path}${search}${hash}`\n\n\t}\n\tgo(index: number) {\n\t\tconst it = this.history?.go(index);\n\t\tif (!it) { return; }\n\t\tthis._update(...it);\n\t}\n\tback() {\n\t\tconst it = this.history?.back();\n\t\tif (!it) { return; }\n\t\tthis._update(...it);\n\t}\n\tforward() {\n\t\tconst it = this.history?.forward();\n\t\tif (!it) { return; }\n\t\tthis._update(...it);\n\t}\n\tget view() {\n\t\tconst view: Component = (props, ...p) =>\n\t\t\tRouterView({...props, router: this}, ...p);\n\t\tNeep.mName('Router', view);\n\t\tReflect.defineProperty(this, 'view', {\n\t\t\tvalue: view,\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t})\n\t\treturn view;\n\t}\n}\n\nexport default Router;"],"names":["contextConstructor","context","router","delivered","__NeepRouter__","depth","__RouteDepth__","Reflect","defineProperty","value","enumerable","configurable","get","_get","Neep","install","neep","addContextConstructor","RouterView","props","createElement","Deliver","label","isNew","Router","Number","isInteger","size","match","route","components","name","component","undefined","path","RouterLink","auxiliary","childNodes","to","append","replace","search","hash","query","alias","params","onclick","push","history","link","cleanPath","test","parse","str","options","tokens","i","length","char","type","index","count","pattern","j","TypeError","code","charCodeAt","lexer","_a","prefixes","defaultPattern","escapeString","delimiter","result","key","tryConsume","mustConsume","nextType","consumeText","prefix","indexOf","suffix","modifier","name_1","pattern_1","compile","reFlags","flags","encode","x","_b","validate","matches","map","token","RegExp","data","optional","repeat","Array","isArray","segment","typeOfMessage","String","tokensToFunction","keys","re","decode","pathname","m","exec","Object","create","split","regexpToFunction","pathToRegexp","sensitive","stringToRegexp","strict","start","_c","end","_d","endsWith","_i","tokens_1","mod","endToken","isEndDelimited","tokensToRegexp","groups","source","regexpToRegexp","paths","parts","join","arrayToRegexp","matchRoutes","routes","redirect","children","getValue","v","isFinite","encodeURIComponent","stringify","s","list","k","val","set","it","decodeURIComponent","substr","mSimple","mName","p","constructor","state","this","go","newIndex","back","forward","onClick","opt","base","f","_update","getPath","location","window","addEventListener","destroy","removeEventListener","pushState","replaceState","old","href","getUrl","e","preventDefault","oldHash","basePath","stringifyQuery","routePath","toPath","update","obj","newKeys","Set","ownKeys","has","redirects","_size","_matches","_alias","_path","_search","_hash","_state","History","historyOption","encase","setRoutes","named","_routes","c","addRoute","cfg","parent","meta","default","item","_namedRoutes","_nodes","_this$_nodes$index","force","last","Error","pop","nodes","nodesLength","matchesLength","min","Math","_this$history3","_this$history4","_this$history5","view"],"mappings":"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"}