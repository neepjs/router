{"version":3,"file":"neep.router.min.js","sources":["../src/install/context.ts","../src/View.ts","../src/Link.ts","../src/install/index.ts","../src/util.ts","../node_modules/path-to-regexp/dist.es2015/index.js","../src/route.ts","../src/query.ts","../src/history/WebHash.ts","../src/history/Memory.ts","../src/history/WebPath.ts","../src/Router.ts","../src/browser.ts"],"sourcesContent":["import { Context } from '@neep/core';\n\nexport default function contextConstructor(context: Context) {\n\tconst router = context.delivered.__NeepRouter__;\n\tconst depth = context.delivered.__RouteDepth__ || 0;\n\tReflect.defineProperty(context, 'route', {\n\t\tvalue: router,\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t});\n\tReflect.defineProperty(context, 'match', {\n\t\tget: () => router?._get(depth),\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t});\n}","import { Context, Auxiliary, mName, mSimple } from '@neep/core';\nimport Router from './Router';\n\nexport interface ViewProps {\n\tname?: string;\n\tdepth?: number;\n\trouter?: Router;\n}\nexport default function RouterView(\n\tprops: ViewProps,\n\t{ delivered }: Context,\n\t{ createElement, Deliver, label }: Auxiliary,\n) {\n\tconst isNew = props.router instanceof Router;\n\tconst router = isNew ? props.router : delivered.__NeepRouter__;\n\tif (!(router instanceof Router)) { return; }\n\tlet depth = props.depth;\n\tif (typeof depth === 'number' && Number.isInteger(depth)) {\n\t\tif (depth < 0) { depth = router.size - depth; }\n\t} else {\n\t\tdepth = isNew ? 0 : (delivered.__RouteDepth__ || 0) + 1;\n\t}\n\tif (depth < 0) { return null; }\n\tconst match = router._get(depth);\n\tif (!match) { return; }\n\tconst { route: { components } } = match;\n\tif (!components) { return null; }\n\tconst name = props.name || 'default';\n\tconst component = name in components ? components[name] : undefined;\n\tif (!component) { return null; }\n\tlabel(`[path=${match.path}]`, '#987654');\n\treturn createElement(Deliver, {\n\t\t__RouteDepth__: depth,\n\t\t__NeepRouter__: router,\n\t}, createElement(component, props));\n}\nmSimple(RouterView);\nmName('RouterView', RouterView);\n","import { Context, Auxiliary, mName, mSimple } from '@neep/core';\nimport { Location } from './type';\n\nexport interface LinkProps extends Location {\n\tto?: Location | string;\n\treplace?: boolean;\n}\nexport default function RouterLink(\n\tprops: LinkProps,\n\tcontext: Context,\n\tauxiliary: Auxiliary,\n) {\n\tconst { route, childNodes } = context;\n\tconst { createElement } = auxiliary;\n\tif (!route) { return createElement('template', {}, ...childNodes); }\n\tlet {to, append, replace, path, search, hash, query, alias, params} = props;\n\tif (!to) {\n\t\tto = { path, search, hash, query, alias, params };\n\t} else if (typeof to === 'string') {\n\t\tto = { path: to };\n\t}\n\tif (append) {\n\t\tto.append = true;\n\t}\n\tfunction onclick() {\n\t\tif (!route || !to) { return; }\n\t\tif (replace) {\n\t\t\troute.replace(to);\n\t\t} else {\n\t\t\troute.push(to);\n\t\t}\n\t}\n\treturn route\n\t\t.history?.link({...props, to}, context, auxiliary, onclick)\n\t\t|| createElement('span', {'@click': onclick}, ...childNodes);\n\n}\nmSimple(RouterLink);\nmName('RouterLink', RouterLink);\n","import contextConstructor from './context';\nimport RouterView from '../View';\nimport RouterLink from '../Link';\n\nexport let Neep: typeof import ('@neep/core');\nexport default function install(neep: typeof import ('@neep/core')) {\n\tNeep = neep;\n\tNeep.addContextConstructor(contextConstructor);\n\tNeep.register('RouterView', RouterView);\n\tNeep.register('router-view', RouterView);\n\tNeep.register('RouterLink', RouterLink);\n\tNeep.register('router-link', RouterLink);\n}\n","export function cleanPath(path: string) {\n\tpath = `/${path}`.replace(/\\/+(\\/|$)/g, '$1');\n\twhile(/[^/]+\\/\\.{2,}(\\/|$)/.test(path)) {\n\t\tpath = path.replace(/\\/[^/]+\\/\\.(\\.+(?:\\/|$))/g, '/$1');\n\t}\n\tpath = path.replace(/\\/\\.+(\\/|$)/g, '$1');\n\treturn path || '/';\n}","/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    var tokens = [];\n    var i = 0;\n    while (i < str.length) {\n        var char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            var name = \"\";\n            var j = i + 1;\n            while (j < str.length) {\n                var code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(\"Missing parameter name at \" + i);\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            var count = 1;\n            var pattern = \"\";\n            var j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \" + j);\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(\"Capturing groups are not allowed at \" + j);\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(\"Unbalanced pattern at \" + i);\n            if (!pattern)\n                throw new TypeError(\"Missing pattern at \" + i);\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var tokens = lexer(str);\n    var _a = options.prefixes, prefixes = _a === void 0 ? \"./\" : _a;\n    var defaultPattern = \"[^\" + escapeString(options.delimiter || \"/#?\") + \"]+?\";\n    var result = [];\n    var key = 0;\n    var i = 0;\n    var path = \"\";\n    var tryConsume = function (type) {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    var mustConsume = function (type) {\n        var value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        var _a = tokens[i], nextType = _a.type, index = _a.index;\n        throw new TypeError(\"Unexpected \" + nextType + \" at \" + index + \", expected \" + type);\n    };\n    var consumeText = function () {\n        var result = \"\";\n        var value;\n        // tslint:disable-next-line\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        var char = tryConsume(\"CHAR\");\n        var name = tryConsume(\"NAME\");\n        var pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            var prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix: prefix,\n                suffix: \"\",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        var value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        var open = tryConsume(\"OPEN\");\n        if (open) {\n            var prefix = consumeText();\n            var name_1 = tryConsume(\"NAME\") || \"\";\n            var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n            var suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name_1 || (pattern_1 ? key++ : \"\"),\n                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n                prefix: prefix,\n                suffix: suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\" + token.pattern + \")$\", reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            var optional = token.modifier === \"?\" || token.modifier === \"*\";\n            var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not repeat, but got an array\");\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not be empty\");\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            var typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to be \" + typeOfMessage);\n        }\n        return path;\n    };\n}\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            // tslint:disable-next-line\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    // Use a negative lookahead to match only capturing groups.\n    var groups = path.source.match(/\\((?!\\?)/g);\n    if (groups) {\n        for (var i = 0; i < groups.length; i++) {\n            keys.push({\n                name: i,\n                prefix: \"\",\n                suffix: \"\",\n                modifier: \"\",\n                pattern: \"\"\n            });\n        }\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\" + parts.join(\"|\") + \")\", flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;\n    var endsWith = \"[\" + escapeString(options.endsWith || \"\") + \"]|$\";\n    var delimiter = \"[\" + escapeString(options.delimiter || \"/#?\") + \"]\";\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var prefix = escapeString(encode(token.prefix));\n            var suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        var mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += \"(?:\" + prefix + \"((?:\" + token.pattern + \")(?:\" + suffix + prefix + \"(?:\" + token.pattern + \"))*)\" + suffix + \")\" + mod;\n                    }\n                    else {\n                        route += \"(?:\" + prefix + \"(\" + token.pattern + \")\" + suffix + \")\" + token.modifier;\n                    }\n                }\n                else {\n                    route += \"(\" + token.pattern + \")\" + token.modifier;\n                }\n            }\n            else {\n                route += \"(?:\" + prefix + suffix + \")\" + token.modifier;\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += delimiter + \"?\";\n        route += !options.endsWith ? \"$\" : \"(?=\" + endsWith + \")\";\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1\n            : // tslint:disable-next-line\n                endToken === undefined;\n        if (!strict) {\n            route += \"(?:\" + delimiter + \"(?=\" + endsWith + \"))?\";\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\" + delimiter + \"|\" + endsWith + \")\";\n        }\n    }\n    return new RegExp(route, flags(options));\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\n//# sourceMappingURL=index.js.map","\nimport { match, compile } from 'path-to-regexp';\nimport { RouteConfig, Route, Match } from './type';\nimport { cleanPath } from './util';\n\n\nexport function addRoute(\n\tcfg: RouteConfig,\n\tnamed: Record<string, Route>,\n\tparent?: Route,\n) {\n\tlet { path, children, alias, meta, component, components, ...p } = cfg;\n\tlet end = !(Array.isArray(children) && children.length);\n\tif (!path || path === '*') {\n\t\tpath = '';\n\t\tend = false;\n\t}\n\tif (path[0] !== '/') {\n\t\tpath = `${parent?.path || ''}/${path}`;\n\t}\n\tpath = cleanPath(path);\n\tif (component) {\n\t\tif (!components) {\n\t\t\tcomponents = {};\n\t\t}\n\t\tcomponents.default = component;\n\t}\n\tconst item: Route = {\n\t\t...p,\n\t\tpath,\n\t\talias,\n\t\tcomponent,\n\t\tcomponents,\n\t\tmeta: meta || {},\n\t\ttoPath: compile(path || '', { encode: encodeURIComponent }),\n\t\tmatch: match(path || '', {end, decode: decodeURIComponent}),\n\t};\n\tif (alias) { named[alias] = item; }\n\tif (Array.isArray(children)) {\n\t\titem.children = children.map(c => addRoute(c, named, item));\n\t}\n\treturn item;\n}\n\nexport function *matchRoutes(path: string, routes: Route[] = []): Iterable<Match>{\n\tfor (const route of routes) {\n\t\tconst result = route.match(path);\n\t\tif (!result) { continue; }\n\t\tif (route.components || route.redirect) {\n\t\t\tyield { ...result, route };\n\t\t}\n\t\tif (!route.redirect) {\n\t\t\tyield* matchRoutes(path, route.children);\n\t\t}\n\t\treturn;\n\t}\n}\n","\nfunction getValue(v: any): string | undefined | null {\n\tif (v === undefined) { return undefined; }\n\tif (v === null) { return null; }\n\tif (v === false) { return undefined; }\n\tif (typeof v === 'number' && !Number.isFinite(v)) { return; }\n\tif (typeof v === 'function') { return; }\n\treturn encodeURIComponent(String(v));\n}\nexport function stringify(s: any): string {\n\tconst list: string[] = [];\n\tfor (const key of Object.keys(s)) {\n\t\tconst value = s[key];\n\t\tconst k = encodeURIComponent(key);\n\t\tif (!Array.isArray(value)) {\n\t\t\tconst v = getValue(value);\n\t\t\tif (v === undefined) { continue; }\n\t\t\tlist.push(v === null ? k : `${k}=${v}`);\n\t\t\tcontinue;\n\t\t}\n\t\tfor (const val of value) {\n\t\t\tconst v = getValue(val);\n\t\t\tif (v === undefined) { continue; }\n\t\t\tlist.push(v === null ? k : `${k}=${v}`);\n\t\t}\n\t}\n\treturn list.join('&');\n}\n\nexport function parse(s: string): object {\n\tconst query = Object.create(null);\n\tfunction set(k: string, v: null | string = null) {\n\t\tif (!(k in query)) {\n\t\t\tquery[k] = v;\n\t\t\treturn;\n\t\t}\n\t\tconst it = query[k];\n\t\tif (Array.isArray(it)) {\n\t\t\tit.push(v);\n\t\t} else {\n\t\t\tquery[k] = [it, v];\n\t\t}\n\n\t}\n\tfor (const it of s.split('&')) {\n\t\tconst index = it.indexOf('=');\n\t\tif (index < 0) {\n\t\t\tset(decodeURIComponent(it));\n\t\t\tcontinue;\n\t\t}\n\t\tconst k = decodeURIComponent(it.substr(0, index));\n\t\tconst v = decodeURIComponent(it.substr(index + 1));\n\t\tset(k, v);\n\t}\n\treturn query;\n}","import { IHistory, Location } from '../type';\nimport Router from '../Router';\nimport { Context, Auxiliary } from '@neep/core';\n\nfunction parse(p: string): [string, string, string] {\n\tconst result = /^([^?#]*)((?:\\?[^#]*)?)((?:#.*)?)$/.exec(p);\n\tif (!result) { return ['/', '', '']; }\n\treturn [result[1] || '/', result[2], result[3]];\n}\n\nexport default class WebPathHistory implements IHistory {\n\trouter: Router;\n\tconstructor(router: Router) {\n\t\tthis.router = router;\n\t\tconst f = () => {\n\t\t\tconst [path, search, hash] = parse(location.hash.substr(1));\n\t\t\tthis.router._update(path, search, hash);\n\t\t};\n\t\twindow.addEventListener('hashchange', f);\n\t\tthis.destroy = () => {\n\t\t\tthis.destroy = () => {};\n\t\t\twindow.removeEventListener('hashchange', f);\n\t\t};\n\t}\n\tstart() {\n\t\tconst [path, search, hash] = parse(location.hash.substr(1));\n\t\tthis.router._update(path, search, hash);\n\t}\n\tdestroy() {}\n\tpush(path: string, search: string, hash: string) {\n\t\tlocation.hash = `#${path}${search}${hash}`;\n\t}\n\treplace(path: string, search: string, hash: string) {\n\t\tlocation.replace(`#${path}${search}${hash}`);\n\t}\n\tgo(index: number) {\n\t\tconst oldHash = location.hash;\n\t\thistory.go(index);\n\t\tconst hash = location.hash;\n\t\tif (hash === oldHash) { return; }\n\t\treturn [...parse(hash.substr(1)), undefined] as [string, string, string, any];\n\t}\n\tback() {\n\t\treturn this.go(-1);\n\t}\n\tforward() {\n\t\treturn this.go(1);\n\t}\n\tlink(\n\t\t{to}: { to: Location },\n\t\t{ childNodes }: Context,\n\t\t{createElement}: Auxiliary,\n\t\tonClick: ()=> void,\n\t) {\n\t\treturn createElement('a', {\n\t\t\thref: `#${this.router.getUrl(to)}`,\n\t\t\t'@click': (e: MouseEvent) => {\n\t\t\t\te.preventDefault(); onClick();\n\t\t\t},\n\t\t}, ...childNodes);\n\t}\n}\n","import { IHistory } from '../type';\nimport Router from '../Router';\nimport { Auxiliary, Context } from '@neep/core';\n\nexport default class StoreHistory implements IHistory {\n\trouter: Router;\n\tconstructor(router: Router) {\n\t\tthis.router = router;\n\t}\n\tindex = 0;\n\thistory: [string, string, string, any][] = [];\n\tpush(\n\t\tpath: string,\n\t\tsearch: string,\n\t\thash: string,\n\t\tstate: any,\n\t) {\n\t\tthis.history.length = this.index + 1;\n\t\tthis.index++;\n\t\tthis.history.push([path, search, hash, state]);\n\t}\n\treplace(\n\t\tpath: string,\n\t\tsearch: string,\n\t\thash: string,\n\t\tstate: any,\n\t) {\n\t\tthis.history[this.index] = [path, search, hash, state];\n\t}\n\tgo(index: number) {\n\t\tlet newIndex = this.index + index;\n\t\tif (newIndex >= this.history.length) { return; }\n\t\tif (newIndex < 0) { return; }\n\t\tif (newIndex === this.index) { return; }\n\t\tthis.index = newIndex;\n\t\treturn this.history[newIndex];\n\t}\n\tback() {\n\t\treturn this.go(-1);\n\t}\n\tforward() {\n\t\treturn this.go(1);\n\t}\n\tlink(\n\t\tprops: any,\n\t\t{ childNodes }: Context,\n\t\t{ createElement }: Auxiliary,\n\t\tonClick: ()=> void,\n\t) {\n\t\treturn createElement('span', { '@click': onClick }, ...childNodes);\n\t}\n}\n","import { IHistory, Location } from '../type';\nimport Router from '../Router';\nimport { cleanPath } from '../util';\nimport { Context, Auxiliary } from '@neep/core';\n\nexport default class WebPathHistory implements IHistory {\n\treadonly router: Router;\n\treadonly base: string;\n\tconstructor(router: Router, opt?: {\n\t\tbase?: string;\n\t}) {\n\t\tthis.router = router;\n\t\tlet base = cleanPath(opt?.base || '');\n\t\tthis.base = base === '/' ? '' : base;\n\t\tconst f = () => {\n\t\t\tthis.router._update(\n\t\t\t\tthis.getPath(),\n\t\t\t\tlocation.search,\n\t\t\t\tlocation.hash,\n\t\t\t\thistory.state,\n\t\t\t);\n\t\t};\n\t\twindow.addEventListener('popstate', f);\n\t\tthis.destroy = () => {\n\t\t\tthis.destroy = () => {};\n\t\t\twindow.removeEventListener('popstate', f);\n\t\t};\n\t}\n\tstart() {\n\t\tthis.router._update(\n\t\t\tthis.getPath(),\n\t\t\tlocation.search,\n\t\t\tlocation.hash,\n\t\t\thistory.state,\n\t\t);\n\t}\n\tdestroy() {}\n\tpush(\n\t\tpath: string,\n\t\tsearch: string,\n\t\thash: string,\n\t\tstate: any,\n\t) {\n\t\thistory.pushState(state, '', `${this.base}${path}${search}${hash}`);\n\t}\n\treplace(\n\t\tpath: string,\n\t\tsearch: string,\n\t\thash: string,\n\t\tstate: any,\n\t) {\n\t\thistory.replaceState(state, '', `${this.base}${path}${search}${hash}`);\n\t}\n\tprivate getPath() {\n\t\tconst path = location.pathname;\n\t\tconst { base } = this;\n\t\tif (!base) { return path; }\n\t\tif (path.indexOf(`${base}/`) !== 0) { return path; }\n\t\treturn path.substr(base.length);\n\t}\n\tgo(index: number) {\n\t\tconst old = {\n\t\t\tpath: this.getPath(),\n\t\t\tsearch: location.search,\n\t\t\thash: location.hash,\n\t\t\tstate: history.state,\n\t\t};\n\t\thistory.go(index);\n\t\tconst path = this.getPath();\n\t\tconst search = location.search;\n\t\tconst hash = location.hash;\n\t\tconst state = history.state;\n\t\tif (\n\t\t\tpath !== old.path\n\t\t\t|| search !== old.search\n\t\t\t|| hash !== old.hash\n\t\t\t|| state !== old.state\n\t\t) {\n\t\t\treturn [path, search, hash, state] as [string, string, string, any];\n\t\t}\n\t}\n\tback() {\n\t\treturn this.go(-1);\n\t}\n\tforward() {\n\t\treturn this.go(1);\n\t}\n\tlink(\n\t\t{to}: { to: Location },\n\t\t{ childNodes }: Context,\n\t\t{createElement}: Auxiliary,\n\t\tonClick: ()=> void,\n\t) {\n\t\treturn createElement('a', {\n\t\t\thref: `${this.base}${this.router.getUrl(to)}`,\n\t\t\t'@click': (e: MouseEvent) => {\n\t\t\t\te.preventDefault(); onClick();\n\t\t\t},\n\t\t}, ...childNodes);\n\t}\n}\n","import install, { Neep } from './install';\nimport { Value } from 'monitorable';\nimport RouterView from './View';\nimport RouterLink from './Link';\nimport { Route, Location, IHistory, Match, RouteConfig } from './type';\nimport { cleanPath } from './util';\nimport { addRoute, matchRoutes } from './route';\nimport { stringify, parse } from './query';\nimport * as history from './history';\nimport { Component } from '@neep/core';\n\nfunction get(\n\tlocation: Location | string,\n\troutes: Record<string, Route>,\n\tbasePath: string,\n\tstringifyQuery = stringify,\n): {\n\tpath: string;\n\tsearch: string;\n\thash: string;\n} {\n\tif (typeof location === 'string') { location = { path: location }; }\n\n\tconst route = location.alias && routes[location.alias];\n\tconst result = location.path && /^([^?#]*)((?:\\?[^#]*)?)((?:#.*)?)$/\n\t\t.exec(location.path);\n\tlet path = result?.[1] || '';\n\tif (!path) {\n\t\tpath = route ? route.toPath(location.params || {}) : basePath;\n\t} else if (route) {\n\t\tlet routePath = route.toPath(location.params || {});\n\t\tif (!location.append) {\n\t\t\troutePath = routePath.replace(/\\/[^/]*\\/?$/, '');\n\t\t}\n\t\tpath = `${route.toPath(location.params || {})}/${path}`;\n\t} else if (location.append) {\n\t\tpath = `${basePath}/${path}`;\n\t} if (path[0] !== '/') {\n\t\tpath = `${basePath.replace(/\\/[^/]*\\/?$/, '')}/${path}`;\n\t}\n\tpath = cleanPath(path);\n\tconst search = location.query && `?${ stringifyQuery(location.query) }`\n\t\t|| location.search || result?.[2] || '';\n\tconst hash = location.hash || result?.[3] || '';\n\treturn { path, search, hash };\n}\n\nfunction update(\n\tobj: any,\n\tprops: any = {},\n) {\n\tconst newKeys = new Set(Reflect.ownKeys(props));\n\tfor (const k of Reflect.ownKeys(obj)) {\n\t\tif (!newKeys.has(k)) {\n\t\t\tdelete obj[k];\n\t\t}\n\t}\n\tfor (const k of newKeys) {\n\t\tobj[k] = props[k];\n\t}\n\treturn obj;\n}\nconst redirects: string[] = [];\nclass Router {\n\tstatic get history() { return history; }\n\tstatic get install() { return install; }\n\tstatic get View() { return RouterView; }\n\tstatic get Link() { return RouterLink; }\n\tstringify?(query: Record<any, any>): string;\n\tparse?(search: string): Record<any, any>;\n\tprivate _namedRoutes: Record<string, Route> = Object.create(null);\n\tprivate _routes: Route[] = [];\n\thistory?: IHistory;\n\tprivate readonly _size = Neep.value(0);\n\tprivate readonly _nodes: Value<Match | undefined>[] = [];\n\tprivate readonly _matches = Neep.value<Match[]>([]);\n\tprivate readonly _hash = Neep.value('');\n\tprivate readonly _search = Neep.value('');\n\tprivate readonly _alias = Neep.value('');\n\tprivate readonly _path = Neep.value('/');\n\tprivate readonly _state = Neep.value(undefined as any);\n\tget size() { return this._size(); }\n\tget matches() { return this._matches(); }\n\tget alias() { return this._alias(); }\n\tget path(): string { return this._path(); }\n\tget search() { return this._search(); }\n\tget hash() { return this._hash(); }\n\tget state() { return this._state(); }\n\treadonly params: Record<string, string> = Neep.encase(Object.create(null));\n\treadonly query: Record<string, any> = Neep.encase(Object.create(null));\n\treadonly meta: Record<string, any> = Neep.encase(Object.create(null));\n\tconstructor({History, historyOption}: {\n\t\tHistory?: {new(router: Router, opt?: any): IHistory }\n\t\thistoryOption?: any;\n\t}) {\n\t\tif (History) {\n\t\t\tconst history = new History(this, historyOption);\n\t\t\tthis.history = history;\n\t\t\thistory.start?.();\n\t\t}\n\t}\n\tsetRoutes(routes: RouteConfig[]) {\n\t\tconst named = Object.create(null);\n\t\tthis._routes = routes.map(c => addRoute(c, named));\n\t\tthis._namedRoutes = named;\n\t\tthis._update(\n\t\t\tthis._path(),\n\t\t\tthis._search(),\n\t\t\tthis._hash(),\n\t\t\tthis._state(),\n\t\t\ttrue,\n\t\t);\n\t}\n\t_get(index: number): Match | undefined {\n\t\tconst item =  this._nodes[index]?.();\n\t\tif (!item) {\n\t\t\tthis._size();\n\t\t\treturn undefined;\n\t\t}\n\t\treturn item;\n\t}\n\t_update(path: string, search: string, hash: string, state?: any, force = false) {\n\t\tif (this._path() !== path || force) {\n\t\t\tconst matches = [...matchRoutes(path, this._routes)];\n\t\t\tconst last = matches[matches.length - 1] as Match | undefined;\n\t\t\tif (last && !last.route.components) {\n\t\t\t\tredirects.push(path);\n\t\t\t\tif (redirects.length >= 10) {\n\t\t\t\t\tthrow new Neep.Error(\n\t\t\t\t\t\t`Too many consecutive redirect jumps: \\n${\n\t\t\t\t\t\t\tredirects.join('\\n')\n\t\t\t\t\t\t}`,\n\t\t\t\t\t\t'router',\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst {redirect, append} = last.route;\n\t\t\t\ttry {\n\t\t\t\t\tif (append) {\n\t\t\t\t\t\tthis.replace(`${path}/${redirect}`, state);\n\t\t\t\t\t} else if (redirect && redirect[0] === '/') {\n\t\t\t\t\t\tthis.replace(redirect, state);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.replace(`${path}/../${redirect}`, state);\n\t\t\t\t\t}\n\t\t\t\t\treturn ;\n\t\t\t\t} finally {\n\t\t\t\t\tredirects.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst nodes = this._nodes;\n\t\t\tconst nodesLength = nodes.length;\n\t\t\tconst matchesLength = matches.length;\n\t\t\tconst min = Math.min(matchesLength, nodesLength);\n\t\t\tfor (let i = 0; i < min; i++) { nodes[i](matches[i]); }\n\t\t\tfor (let i = min; i < nodesLength; i++) {\n\t\t\t\tnodes[i](undefined);\n\t\t\t}\n\t\t\tfor (let i = min; i < matchesLength; i++) {\n\t\t\t\tnodes[i] = Neep.value(matches[i]);\n\t\t\t}\n\t\t\tnodes.length = matchesLength;\n\t\t\tthis._size(matchesLength);\n\t\t\tthis._matches(matches);\n\t\t\tthis._path(path);\n\t\t\tthis._alias(last?.route?.alias || '');\n\t\t\tupdate(this.params, last?.params || {});\n\t\t\tupdate(this.meta, last?.route?.meta || {});\n\t\t}\n\t\tif (this._search() !== search) {\n\t\t\tthis._search(search);\n\t\t\tupdate(this.query, (this.parse || parse)(search.substr(1)));\n\t\t}\n\t\tthis._hash(hash);\n\t\tthis._state(state);\n\t}\n\tpush(location: Location | string, state?: any) {\n\t\tconst { path, search, hash } = get(\n\t\t\tlocation,\n\t\t\tthis._namedRoutes,\n\t\t\tthis._path(),\n\t\t\tthis.stringify,\n\t\t);\n\t\tthis.history?.push(path, search, hash, state);\n\t\tthis._update(path, search, hash, state);\n\t}\n\treplace(location: Location | string, state?: any) {\n\t\tconst {path, search, hash} = get(\n\t\t\tlocation,\n\t\t\tthis._namedRoutes,\n\t\t\tthis._path(),\n\t\t\tthis.stringify,\n\t\t);\n\t\tthis.history?.replace(path, search, hash, state);\n\t\tthis._update(path, search, hash, state);\n\t}\n\tgetUrl(location: Location | string) {\n\t\tconst {path, search, hash} = get(\n\t\t\tlocation,\n\t\t\tthis._namedRoutes,\n\t\t\tthis._path(),\n\t\t\tthis.stringify,\n\t\t);\n\t\treturn `${path}${search}${hash}`;\n\n\t}\n\tgo(index: number) {\n\t\tconst it = this.history?.go(index);\n\t\tif (!it) { return; }\n\t\tthis._update(...it);\n\t}\n\tback() {\n\t\tconst it = this.history?.back();\n\t\tif (!it) { return; }\n\t\tthis._update(...it);\n\t}\n\tforward() {\n\t\tconst it = this.history?.forward();\n\t\tif (!it) { return; }\n\t\tthis._update(...it);\n\t}\n\tget view() {\n\t\tconst view: Component = (props, ...p) =>\n\t\t\tRouterView({...props, router: this}, ...p);\n\t\tNeep.mName('Router', view);\n\t\tReflect.defineProperty(this, 'view', {\n\t\t\tvalue: view,\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t});\n\t\treturn view;\n\t}\n}\n\nexport default Router;\n","import * as Neep from '@neep/core';\nimport Router from '.';\n\nRouter.install(Neep);\nexport { default } from '.';\n"],"names":["contextConstructor","context","router","delivered","__NeepRouter__","depth","__RouteDepth__","Reflect","defineProperty","value","enumerable","configurable","get","_get","RouterView","props","createElement","Deliver","label","isNew","Router","Number","isInteger","size","match","route","components","name","component","undefined","path","RouterLink","auxiliary","childNodes","to","append","replace","search","hash","query","alias","params","onclick","push","history","link","Neep","install","neep","addContextConstructor","register","cleanPath","test","parse","str","options","tokens","i","length","char","type","index","count","pattern","j","TypeError","code","charCodeAt","lexer","_a","prefixes","defaultPattern","escapeString","delimiter","result","key","tryConsume","mustConsume","nextType","consumeText","prefix","indexOf","suffix","modifier","name_1","pattern_1","compile","reFlags","flags","encode","x","_b","validate","matches","map","token","RegExp","data","optional","repeat","Array","isArray","segment","typeOfMessage","String","tokensToFunction","keys","re","decode","pathname","m","exec","Object","create","split","regexpToFunction","pathToRegexp","sensitive","stringToRegexp","strict","start","_c","end","_d","endsWith","_i","tokens_1","mod","endToken","isEndDelimited","tokensToRegexp","groups","source","regexpToRegexp","paths","parts","join","arrayToRegexp","matchRoutes","routes","redirect","children","getValue","v","isFinite","encodeURIComponent","stringify","s","list","k","val","set","it","decodeURIComponent","substr","p","constructor","state","this","go","newIndex","back","forward","onClick","opt","base","f","_update","getPath","location","window","addEventListener","destroy","removeEventListener","pushState","replaceState","old","href","getUrl","e","preventDefault","oldHash","basePath","stringifyQuery","routePath","toPath","update","obj","newKeys","Set","ownKeys","has","redirects","_size","_matches","_alias","_path","_search","_hash","_state","History","historyOption","encase","setRoutes","named","_routes","c","addRoute","cfg","parent","meta","default","item","_namedRoutes","_nodes","_this$_nodes$index","force","last","Error","pop","nodes","nodesLength","matchesLength","min","Math","_this$history3","_this$history4","_this$history5","view","mName"],"mappings":"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"}